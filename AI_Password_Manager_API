import numpy as np
import random
import secrets
import threading
import hashlib
import os
import time
from flask import Flask, request, jsonify
from Crypto.Cipher import AES, ChaCha20, Twofish
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Random import get_random_bytes
from sklearn.ensemble import RandomForestClassifier

# Sample historical data
sample_data = np.array([
    [10, 1, 1, 0], [15, 2, 1, 1], [20, 0, 0, 2], [25, 1, 1, 0], 
    [12, 2, 1, 1], [18, 0, 0, 2], [22, 1, 1, 0], [30, 2, 0, 1]
])
X = sample_data[:, :3]  # Features
y = sample_data[:, 3]   # Labels

# Train a Random Forest model
model = RandomForestClassifier()
model.fit(X, y)

app = Flask(__name__)

class AIEnhancedEncryptor:
    def __init__(self, model):
        self.model = model
        self.encryption_scheme = self.generate_new_scheme()
        self.aes_key = get_random_bytes(16)  # AES key
        self.chacha20_key = get_random_bytes(32)  # ChaCha20 key
        self.twofish_key = get_random_bytes(16)  # Twofish key
        self.rsa_key = RSA.generate(2048)
        self.encryption_methods = ['AES', 'RSA', 'ChaCha20', 'Twofish']
        
    def generate_new_scheme(self):
        return ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()', k=16))

    def encrypt(self, segment, method_index):
        method = self.encryption_methods[method_index]
        segment = segment.encode()
        if method == 'AES':
            cipher = AES.new(self.aes_key, AES.MODE_EAX)
            ciphertext, tag = cipher.encrypt_and_digest(segment)
            return cipher.nonce + tag + ciphertext
        elif method == 'RSA':
            cipher = PKCS1_OAEP.new(self.rsa_key.publickey())
            ciphertext = cipher.encrypt(segment)
            return ciphertext
        elif method == 'ChaCha20':
            cipher = ChaCha20.new(key=self.chacha20_key)
            ciphertext = cipher.encrypt(segment)
            return cipher.nonce + ciphertext
        elif method == 'Twofish':
            cipher = Twofish.new(self.twofish_key, Twofish.MODE_EAX)
            ciphertext, tag = cipher.encrypt_and_digest(segment)
            return cipher.nonce + tag + ciphertext

    def decrypt(self, encrypted_data, scheme, method_index):
        method = self.encryption_methods[method_index]
        if method == 'AES':
            nonce, tag, ciphertext = encrypted_data[:16], encrypted_data[16:32], encrypted_data[32:]
            cipher = AES.new(self.aes_key, AES.MODE_EAX, nonce=nonce)
            return cipher.decrypt_and_verify(ciphertext, tag).decode()
        elif method == 'RSA':
            cipher = PKCS1_OAEP.new(self.rsa_key)
            return cipher.decrypt(encrypted_data).decode()
        elif method == 'ChaCha20':
            nonce, ciphertext = encrypted_data[:8], encrypted_data[8:]
            cipher = ChaCha20.new(key=self.chacha20_key, nonce=nonce)
            return cipher.decrypt(ciphertext).decode()
        elif method == 'Twofish':
            nonce, tag, ciphertext = encrypted_data[:16], encrypted_data[16:32], encrypted_data[32:]
            cipher = Twofish.new(self.twofish_key, Twofish.MODE_EAX, nonce=nonce)
            return cipher.decrypt_and_verify(ciphertext, tag).decode()

    def update_encryption_scheme(self):
        self.encryption_scheme = self.generate_new_scheme()
        self.aes_key = get_random_bytes(16)  
        self.chacha20_key = get_random_bytes(32)
        self.twofish_key = get_random_bytes(16)

    def select_encryption_method(self, segment_length, data_type, previous_success):
        input_data = np.array([[segment_length, data_type, previous_success]])
        method_index = self.model.predict(input_data)[0]
        return method_index

class PasswordEncryptor:
    def __init__(self, ai_encryptor):
        self.ai_encryptor = ai_encryptor
        self.update_interval = 3600
        self.attempts = 0
        self.locked = False
        threading.Thread(target=self.regular_update).start()

    def add_salt_and_hash(self, password):
        salt = secrets.token_hex(8)
        salted_password = password + salt
        hashed_password = hashlib.sha256(salted_password.encode()).hexdigest()
        return hashed_password, salt

    def dynamic_encrypt(self, password, salt):
        segment_count = max(1, len(password) // 4)  # Adjust the number of segments based on password length
        segment_size = len(password) // segment_count  # Calculate the size of each segment
        encrypted_segments = []
        
        for segment_index in range(segment_count):
            start_index = segment_index * segment_size
            end_index = len(password) if segment_index == segment_count - 1 else start_index + segment_size
            segment = password[start_index:end_index]
            method_index = self.ai_encryptor.select_encryption_method(segment_size, 1, 1)
            encrypted_part = self.ai_encryptor.encrypt(segment + salt, method_index)
            encrypted_segments.append((self.ai_encryptor.encryption_methods[method_index], encrypted_part.hex()))
        
        encrypted_password = ''.join([segment[1] for segment in encrypted_segments])
        
        return encrypted_segments, encrypted_password

    def dynamic_decrypt(self, encrypted_data, segments, method):
        if self.locked:
            raise Exception("Too many incorrect attempts. Please wait for the next update cycle.")
        self.attempts += 1
        if self.attempts > 5:  
            self.locked = True
            return "Locked due to too many attempts. Wait for the next cycle."
        
        decrypted_segments = []
        for segment, enc_data in zip(segments, encrypted_data):
            method_name, encrypted_segment = segment
            decrypted_segment = self.ai_encryptor.decrypt(bytes.fromhex(encrypted_segment), method_name, method)
            decrypted_segments.append(decrypted_segment)

        decrypted_password = ''.join(decrypted_segments)
        return decrypted_password[:-16]  # Removing the salt

    def regular_update(self):
        while True:
            self.ai_encryptor.update_encryption_scheme()
            self.attempts = 0 
            self.locked = False  
            time.sleep(self.update_interval)

    def log_audit_event(self, event):
        with open("audit_log.txt", "a") as log_file:
            log_file.write(f"{time.ctime()} - {event}\n")

    def start_encryption(self, user_password):
        hashed_password, password_salt = self.add_salt_and_hash(user_password)
        segments, encrypted_password = self.dynamic_encrypt(hashed_password, password_salt)
        self.log_audit_event(f"Password encrypted: {encrypted_password}")

        return {
            "Original Password": user_password,
            "Salt": password_salt,
            "Hashed Password": hashed_password,
            "Encryption Segments": segments,
            "Encrypted Password": encrypted_password
        }

# Create instances
ai_encryptor = AIEnhancedEncryptor(model)
password_encryptor = PasswordEncryptor(ai_encryptor)

@app.route('/encrypt', methods=['POST'])
def encrypt_password():
    data = request.json
    user_password = data.get('password', '')
    result = password_encryptor.start_encryption(user_password)
    return jsonify(result)

@app.route('/decrypt', methods=['POST'])
def decrypt_password():
    data = request.json
    encrypted_password = data.get('encrypted_password', '')
    scheme = data.get('scheme', '')
    method = data.get('method', '')
    try:
        decrypted_password = password_encryptor.dynamic_decrypt(encrypted_password, scheme, method)
        return jsonify({"Decrypted Password": decrypted_password})
    except Exception as e:
        return jsonify({"error": str(e)}), 400

if __name__ == '__main__':
    app.run(debug=True)
